/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Coder Community
 * The Coder Community API description
 *
 * OpenAPI spec version: 0.0.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from "url";
import portableFetch from "../api-auth/fetch-container"; // modified by backend/scripts/generate-api.js
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:3001".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface CreateConversationBodyDto
 */
export interface CreateConversationBodyDto {
    /**
     * 
     * @type {string}
     * @memberof CreateConversationBodyDto
     */
    userID: string;
    /**
     * 
     * @type {string}
     * @memberof CreateConversationBodyDto
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateConversationBodyDto
     */
    users: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateConversationBodyDto
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateConversationBodyDto
     */
    createdAt: number;
}
/**
 * 
 * @export
 * @interface CreateConversationSuccessDto
 */
export interface CreateConversationSuccessDto {
    /**
     * 
     * @type {string}
     * @memberof CreateConversationSuccessDto
     */
    _id: string; // modified by backend/scripts/generate-api.js
    /**
     * 
     * @type {string}
     * @memberof CreateConversationSuccessDto
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateConversationSuccessDto
     */
    users: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateConversationSuccessDto
     */
    messages: Array<string>;
    /**
     * 
     * @type {any}
     * @memberof CreateConversationSuccessDto
     */
    createdAt: any;
}
/**
 * 
 * @export
 * @interface CreateCustomUser
 */
export interface CreateCustomUser {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomUser
     */
    userID: string;
}
/**
 * 
 * @export
 * @interface CreateGroupDto
 */
export interface CreateGroupDto {
    /**
     * The name of the group
     * @type {string}
     * @memberof CreateGroupDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupDto
     */
    description?: string;
    /**
     * The ObjectIDs of the invited users of the new group
     * @type {Array<string>}
     * @memberof CreateGroupDto
     */
    users: Array<string>;
    /**
     * The URL for the group's circular profile avatar image
     * @type {string}
     * @memberof CreateGroupDto
     */
    profilePic?: string;
    /**
     * The URL for the group's background image
     * @type {string}
     * @memberof CreateGroupDto
     */
    profileBanner?: string;
    /**
     * Whether the group is viewable by non-members
     * @type {boolean}
     * @memberof CreateGroupDto
     */
    private: boolean; // modified by backend/scripts/generate-api.js
}
/**
 * 
 * @export
 * @interface CreateGroupSuccessDto
 */
export interface CreateGroupSuccessDto {
    /**
     * The newly created group's object ID
     * @type {string}
     * @memberof CreateGroupSuccessDto
     */
    _id: string; // modified by backend/scripts/generate-api.js
}
/**
 * 
 * @export
 * @interface CreateMessageBodyDto
 */
export interface CreateMessageBodyDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMessageBodyDto
     */
    userID: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMessageBodyDto
     */
    conversationID: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMessageBodyDto
     */
    text: string;
    /**
     * 
     * @type {number}
     * @memberof CreateMessageBodyDto
     */
    createdAt: number;
}
/**
 * 
 * @export
 * @interface CreateMessageSuccessDto
 */
export interface CreateMessageSuccessDto {
    /**
     * 
     * @type {string}
     * @memberof CreateMessageSuccessDto
     */
    conversationID: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMessageSuccessDto
     */
    _id: string; // modified by backend/scripts/generate-api.js
    /**
     * 
     * @type {string}
     * @memberof CreateMessageSuccessDto
     */
    author: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMessageSuccessDto
     */
    text: string;
    /**
     * 
     * @type {number}
     * @memberof CreateMessageSuccessDto
     */
    createdAt: number;
    /**
     * 
     * @type {number}
     * @memberof CreateMessageSuccessDto
     */
    updatedAt?: number;
}
/**
 * 
 * @export
 * @interface CreatePostBodyDto
 */
export interface CreatePostBodyDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePostBodyDto
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePostBodyDto
     */
    content: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreatePostBodyDto
     */
    tags: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreatePostBodyDto
     */
    featuredImg: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePostBodyDto
     */
    group?: string;
}
/**
 * 
 * @export
 * @interface CreatePostSuccessDto
 */
export interface CreatePostSuccessDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePostSuccessDto
     */
    _id: string; // modified by backend/scripts/generate-api.js
    /**
     * 
     * @type {string}
     * @memberof CreatePostSuccessDto
     */
    slug: string;
}
/**
 * 
 * @export
 * @interface CreateVideoDto
 */
export interface CreateVideoDto {
    /**
     * 
     * @type {string}
     * @memberof CreateVideoDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVideoDto
     */
    description: string;
}
/**
 * 
 * @export
 * @interface FileUploadDto
 */
export interface FileUploadDto {
    /**
     * 
     * @type {any}
     * @memberof FileUploadDto
     */
    file: any;
}
/**
 * 
 * @export
 * @interface GetAllVideosDto
 */
export interface GetAllVideosDto {
    /**
     * 
     * @type {Array<VideoDto>}
     * @memberof GetAllVideosDto
     */
    videos: Array<VideoDto>;
}
/**
 * 
 * @export
 * @interface GetGroupMembersAndPostsDto
 */
export interface GetGroupMembersAndPostsDto {
    /**
     * 
     * @type {Array<UserDto>}
     * @memberof GetGroupMembersAndPostsDto
     */
    admins: Array<UserDto>;
    /**
     * 
     * @type {Array<UserDto>}
     * @memberof GetGroupMembersAndPostsDto
     */
    users: Array<UserDto>;
    /**
     * 
     * @type {Array<PostDto>}
     * @memberof GetGroupMembersAndPostsDto
     */
    posts: Array<PostDto>;
}
/**
 * 
 * @export
 * @interface GetGroupsSuccessDto
 */
export interface GetGroupsSuccessDto {
    /**
     * 
     * @type {Array<GroupDto>}
     * @memberof GetGroupsSuccessDto
     */
    groups: Array<GroupDto>;
}
/**
 * 
 * @export
 * @interface GetInitialDataDto
 */
export interface GetInitialDataDto {
    /**
     * 
     * @type {Array<PostDto>}
     * @memberof GetInitialDataDto
     */
    posts: Array<PostDto>;
    /**
     * 
     * @type {Array<UserDto>}
     * @memberof GetInitialDataDto
     */
    users: Array<UserDto>;
    /**
     * 
     * @type {Array<TagsDto>}
     * @memberof GetInitialDataDto
     */
    tags: Array<TagsDto>;
}
/**
 * 
 * @export
 * @interface GetInitialDataLoggedInDto
 */
export interface GetInitialDataLoggedInDto {
    /**
     * 
     * @type {Array<PostDto>}
     * @memberof GetInitialDataLoggedInDto
     */
    posts: Array<PostDto>;
    /**
     * 
     * @type {Array<UserDto>}
     * @memberof GetInitialDataLoggedInDto
     */
    users: Array<UserDto>;
    /**
     * 
     * @type {UserDto}
     * @memberof GetInitialDataLoggedInDto
     */
    user: UserDto;
    /**
     * 
     * @type {Array<TagsDto>}
     * @memberof GetInitialDataLoggedInDto
     */
    tags: Array<TagsDto>;
}
/**
 * 
 * @export
 * @interface GetPostDetailsSuccessDto
 */
export interface GetPostDetailsSuccessDto {
    /**
     * 
     * @type {PostWithDetails}
     * @memberof GetPostDetailsSuccessDto
     */
    post: PostWithDetails;
    /**
     * 
     * @type {UserDto}
     * @memberof GetPostDetailsSuccessDto
     */
    author?: UserDto;
}
/**
 * 
 * @export
 * @interface GetPostsByTagDto
 */
export interface GetPostsByTagDto {
    /**
     * 
     * @type {number}
     * @memberof GetPostsByTagDto
     */
    cursor: number;
    /**
     * 
     * @type {string}
     * @memberof GetPostsByTagDto
     */
    tagID: string;
    /**
     * 
     * @type {Array<PostDto>}
     * @memberof GetPostsByTagDto
     */
    posts: Array<PostDto>;
}
/**
 * 
 * @export
 * @interface GetUsersSuccessDto
 */
export interface GetUsersSuccessDto {
    /**
     * 
     * @type {Array<UserDto>}
     * @memberof GetUsersSuccessDto
     */
    users: Array<UserDto>;
}
/**
 * 
 * @export
 * @interface GitHubLoginBody
 */
export interface GitHubLoginBody {
    /**
     * 
     * @type {string}
     * @memberof GitHubLoginBody
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof GitHubLoginBody
     */
    state: string;
}
/**
 * 
 * @export
 * @interface GoogleLoginBody
 */
export interface GoogleLoginBody {
}
/**
 * 
 * @export
 * @interface GroupDto
 */
export interface GroupDto {
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    _id: string; // modified by backend/scripts/generate-api.js
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    description: string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupDto
     */
    private: boolean; // modified by backend/scripts/generate-api.js
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    profilePic: string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    profileBanner: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupDto
     */
    admins: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupDto
     */
    users: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupDto
     */
    posts: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupDto
     */
    videos: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof GroupDto
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface LogOut
 */
export interface LogOut {
}
/**
 * 
 * @export
 * @interface LogOutSuccess
 */
export interface LogOutSuccess {
}
/**
 * 
 * @export
 * @interface LoginSuccess
 */
export interface LoginSuccess {
    /**
     * The CoderCommunity JWT
     * @type {string}
     * @memberof LoginSuccess
     */
    jwt: string;
    /**
     * The MongoDB user _id
     * @type {string}
     * @memberof LoginSuccess
     */
    _id: string; // modified by backend/scripts/generate-api.js
    /**
     * The visible User ID
     * @type {string}
     * @memberof LoginSuccess
     */
    userID: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginSuccess
     */
    isNewUser: boolean;
}
/**
 * 
 * @export
 * @interface MessageDto
 */
export interface MessageDto {
    /**
     * 
     * @type {string}
     * @memberof MessageDto
     */
    _id: string; // modified by backend/scripts/generate-api.js
    /**
     * 
     * @type {string}
     * @memberof MessageDto
     */
    author: string;
    /**
     * 
     * @type {string}
     * @memberof MessageDto
     */
    text: string;
    /**
     * 
     * @type {any}
     * @memberof MessageDto
     */
    createdAt: any;
    /**
     * 
     * @type {any}
     * @memberof MessageDto
     */
    updatedAt: any;
}
/**
 * 
 * @export
 * @interface Post
 */
export interface Post {
    /**
     * 
     * @type {any}
     * @memberof Post
     */
    author: any;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    previewContent: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    content: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof Post
     */
    tags: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    featuredImg: string;
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    likes: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof Post
     */
    comments: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    views: number;
    /**
     * 
     * @type {any}
     * @memberof Post
     */
    group: any;
}
/**
 * 
 * @export
 * @interface PostDto
 */
export interface PostDto {
    /**
     * 
     * @type {string}
     * @memberof PostDto
     */
    _id: string; // modified by backend/scripts/generate-api.js
    /**
     * 
     * @type {string}
     * @memberof PostDto
     */
    author: string;
    /**
     * 
     * @type {string}
     * @memberof PostDto
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof PostDto
     */
    previewContent?: string;
    /**
     * 
     * @type {string}
     * @memberof PostDto
     */
    content?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostDto
     */
    tags: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PostDto
     */
    featuredImg: string;
    /**
     * 
     * @type {number}
     * @memberof PostDto
     */
    likes: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostDto
     */
    comments: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof PostDto
     */
    commentsCount: number;
    /**
     * 
     * @type {number}
     * @memberof PostDto
     */
    views: number;
    /**
     * 
     * @type {string}
     * @memberof PostDto
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof PostDto
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof PostDto
     */
    group?: string;
}
/**
 * 
 * @export
 * @interface PostWithDetails
 */
export interface PostWithDetails {
    /**
     * 
     * @type {string}
     * @memberof PostWithDetails
     */
    _id: string; // modified by backend/scripts/generate-api.js
    /**
     * 
     * @type {string}
     * @memberof PostWithDetails
     */
    author: string;
    /**
     * 
     * @type {string}
     * @memberof PostWithDetails
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof PostWithDetails
     */
    previewContent: string;
    /**
     * 
     * @type {string}
     * @memberof PostWithDetails
     */
    content: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostWithDetails
     */
    tags: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PostWithDetails
     */
    featuredImg: string;
    /**
     * 
     * @type {number}
     * @memberof PostWithDetails
     */
    likes: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostWithDetails
     */
    comments: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof PostWithDetails
     */
    commentsCount: number;
    /**
     * 
     * @type {number}
     * @memberof PostWithDetails
     */
    views: number;
    /**
     * 
     * @type {string}
     * @memberof PostWithDetails
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof PostWithDetails
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof PostWithDetails
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof PostWithDetails
     */
    group?: string;
}
/**
 * 
 * @export
 * @interface SearchResultDto
 */
export interface SearchResultDto {
    /**
     * 
     * @type {Array<Post>}
     * @memberof SearchResultDto
     */
    posts: Array<Post>;
}
/**
 * 
 * @export
 * @interface TagsDto
 */
export interface TagsDto {
    /**
     * 
     * @type {string}
     * @memberof TagsDto
     */
    _id: string; // modified by backend/scripts/generate-api.js
    /**
     * 
     * @type {string}
     * @memberof TagsDto
     */
    name: string;
}
/**
 * 
 * @export
 * @interface UpdatePostBodyDto
 */
export interface UpdatePostBodyDto {
    /**
     * 
     * @type {string}
     * @memberof UpdatePostBodyDto
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePostBodyDto
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePostBodyDto
     */
    featuredImg?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdatePostBodyDto
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdatePostBodyDto
     */
    oldSlug?: string;
}
/**
 * 
 * @export
 * @interface UpdatePostSuccessDto
 */
export interface UpdatePostSuccessDto {
    /**
     * 
     * @type {string}
     * @memberof UpdatePostSuccessDto
     */
    _id: string; // modified by backend/scripts/generate-api.js
    /**
     * 
     * @type {string}
     * @memberof UpdatePostSuccessDto
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePostSuccessDto
     */
    oldSlug?: string;
}
/**
 * 
 * @export
 * @interface UpdateProfileReqDto
 */
export interface UpdateProfileReqDto {
    /**
     * Updated name
     * @type {string}
     * @memberof UpdateProfileReqDto
     */
    name?: string;
    /**
     * Updated status
     * @type {string}
     * @memberof UpdateProfileReqDto
     */
    status?: string;
    /**
     * Array of tag ObjectIDs, which will completely replace the previous tags of the user
     * @type {Array<string>}
     * @memberof UpdateProfileReqDto
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface UploadSuccess
 */
export interface UploadSuccess {
    /**
     * The URL of the file which is now statically served as a result of this upload.
     * @type {string}
     * @memberof UploadSuccess
     */
    url: string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    _id: string; // modified by backend/scripts/generate-api.js
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    userID: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    profilePic?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    profileBanner?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    status?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserDto
     */
    followers?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserDto
     */
    following?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserDto
     */
    groups?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserDto
     */
    posts?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserDto
     */
    savedPosts?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserDto
     */
    likedPosts: Array<string>;
}
/**
 * 
 * @export
 * @interface VideoDto
 */
export interface VideoDto {
    /**
     * 
     * @type {string}
     * @memberof VideoDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VideoDto
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof VideoDto
     */
    _id: string; // modified by backend/scripts/generate-api.js
    /**
     * 
     * @type {string}
     * @memberof VideoDto
     */
    createdAt: string;
}
/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LogOut} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogOut(body: LogOut, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling authControllerLogOut.');
            }
            const localVarPath = `/api/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LogOut" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GitHubLoginBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginGitHub(body: GitHubLoginBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling authControllerLoginGitHub.');
            }
            const localVarPath = `/api/login/github`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GitHubLoginBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GoogleLoginBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginGoogle(body: GoogleLoginBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling authControllerLoginGoogle.');
            }
            const localVarPath = `/api/login/google`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GoogleLoginBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LogOut} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogOut(body: LogOut, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LogOutSuccess> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerLogOut(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {GitHubLoginBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginGitHub(body: GitHubLoginBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoginSuccess> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerLoginGitHub(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {GoogleLoginBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginGoogle(body: GoogleLoginBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoginSuccess> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authControllerLoginGoogle(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {LogOut} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogOut(body: LogOut, options?: any) {
            return AuthApiFp(configuration).authControllerLogOut(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {GitHubLoginBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginGitHub(body: GitHubLoginBody, options?: any) {
            return AuthApiFp(configuration).authControllerLoginGitHub(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {GoogleLoginBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginGoogle(body: GoogleLoginBody, options?: any) {
            return AuthApiFp(configuration).authControllerLoginGoogle(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {LogOut} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogOut(body: LogOut, options?: any) {
        return AuthApiFp(this.configuration).authControllerLogOut(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {GitHubLoginBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLoginGitHub(body: GitHubLoginBody, options?: any) {
        return AuthApiFp(this.configuration).authControllerLoginGitHub(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {GoogleLoginBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLoginGoogle(body: GoogleLoginBody, options?: any) {
        return AuthApiFp(this.configuration).authControllerLoginGoogle(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ConversationsApi - fetch parameter creator
 * @export
 */
export const ConversationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateConversationBodyDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsControllerCreateConversation(body: CreateConversationBodyDto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling conversationsControllerCreateConversation.');
            }
            const localVarPath = `/api/conversations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateConversationBodyDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationsApi - functional programming interface
 * @export
 */
export const ConversationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateConversationBodyDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsControllerCreateConversation(body: CreateConversationBodyDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateConversationSuccessDto> {
            const localVarFetchArgs = ConversationsApiFetchParamCreator(configuration).conversationsControllerCreateConversation(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConversationsApi - factory interface
 * @export
 */
export const ConversationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CreateConversationBodyDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationsControllerCreateConversation(body: CreateConversationBodyDto, options?: any) {
            return ConversationsApiFp(configuration).conversationsControllerCreateConversation(body, options)(fetch, basePath);
        },
    };
};

/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
export class ConversationsApi extends BaseAPI {
    /**
     * 
     * @param {CreateConversationBodyDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public conversationsControllerCreateConversation(body: CreateConversationBodyDto, options?: any) {
        return ConversationsApiFp(this.configuration).conversationsControllerCreateConversation(body, options)(this.fetch, this.basePath);
    }

}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options: any = {}): FetchArgs {
            const localVarPath = `/api/hello`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).appControllerGetHello(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appControllerGetHello(options?: any) {
            return DefaultApiFp(configuration).appControllerGetHello(options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appControllerGetHello(options?: any) {
        return DefaultApiFp(this.configuration).appControllerGetHello(options)(this.fetch, this.basePath);
    }

}
/**
 * DevApi - fetch parameter creator
 * @export
 */
export const DevApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCustomUser} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerCreateCustomUser(body: CreateCustomUser, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling devControllerCreateCustomUser.');
            }
            const localVarPath = `/api/dev/create-user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateCustomUser" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerCreatePostDev(options: any = {}): FetchArgs {
            const localVarPath = `/api/dev/create-post`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerGetJwt(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling devControllerGetJwt.');
            }
            const localVarPath = `/api/dev/jwt/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerLoginDev(options: any = {}): FetchArgs {
            const localVarPath = `/api/dev/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerMarco(options: any = {}): FetchArgs {
            const localVarPath = `/api/dev/marco`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerMarcoPersonal(options: any = {}): FetchArgs {
            const localVarPath = `/api/dev/marco/personal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevApi - functional programming interface
 * @export
 */
export const DevApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCustomUser} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerCreateCustomUser(body: CreateCustomUser, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoginSuccess> {
            const localVarFetchArgs = DevApiFetchParamCreator(configuration).devControllerCreateCustomUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerCreatePostDev(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreatePostSuccessDto> {
            const localVarFetchArgs = DevApiFetchParamCreator(configuration).devControllerCreatePostDev(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerGetJwt(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DevApiFetchParamCreator(configuration).devControllerGetJwt(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerLoginDev(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoginSuccess> {
            const localVarFetchArgs = DevApiFetchParamCreator(configuration).devControllerLoginDev(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerMarco(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DevApiFetchParamCreator(configuration).devControllerMarco(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerMarcoPersonal(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DevApiFetchParamCreator(configuration).devControllerMarcoPersonal(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DevApi - factory interface
 * @export
 */
export const DevApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CreateCustomUser} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerCreateCustomUser(body: CreateCustomUser, options?: any) {
            return DevApiFp(configuration).devControllerCreateCustomUser(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerCreatePostDev(options?: any) {
            return DevApiFp(configuration).devControllerCreatePostDev(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerGetJwt(id: string, options?: any) {
            return DevApiFp(configuration).devControllerGetJwt(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerLoginDev(options?: any) {
            return DevApiFp(configuration).devControllerLoginDev(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerMarco(options?: any) {
            return DevApiFp(configuration).devControllerMarco(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devControllerMarcoPersonal(options?: any) {
            return DevApiFp(configuration).devControllerMarcoPersonal(options)(fetch, basePath);
        },
    };
};

/**
 * DevApi - object-oriented interface
 * @export
 * @class DevApi
 * @extends {BaseAPI}
 */
export class DevApi extends BaseAPI {
    /**
     * 
     * @param {CreateCustomUser} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevApi
     */
    public devControllerCreateCustomUser(body: CreateCustomUser, options?: any) {
        return DevApiFp(this.configuration).devControllerCreateCustomUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevApi
     */
    public devControllerCreatePostDev(options?: any) {
        return DevApiFp(this.configuration).devControllerCreatePostDev(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevApi
     */
    public devControllerGetJwt(id: string, options?: any) {
        return DevApiFp(this.configuration).devControllerGetJwt(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevApi
     */
    public devControllerLoginDev(options?: any) {
        return DevApiFp(this.configuration).devControllerLoginDev(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevApi
     */
    public devControllerMarco(options?: any) {
        return DevApiFp(this.configuration).devControllerMarco(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevApi
     */
    public devControllerMarcoPersonal(options?: any) {
        return DevApiFp(this.configuration).devControllerMarcoPersonal(options)(this.fetch, this.basePath);
    }

}
/**
 * GroupsApi - fetch parameter creator
 * @export
 */
export const GroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateGroupDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerCreateGroup(body: CreateGroupDto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling groupsControllerCreateGroup.');
            }
            const localVarPath = `/api/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateGroupDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetGroups(options: any = {}): FetchArgs {
            const localVarPath = `/api/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetMembersAndPosts(groupID: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID','Required parameter groupID was null or undefined when calling groupsControllerGetMembersAndPosts.');
            }
            const localVarPath = `/api/groups/membersAndPosts/{groupID}`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} privateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetPrivateGroup(privateId: string, options: any = {}): FetchArgs {
            // verify required parameter 'privateId' is not null or undefined
            if (privateId === null || privateId === undefined) {
                throw new RequiredError('privateId','Required parameter privateId was null or undefined when calling groupsControllerGetPrivateGroup.');
            }
            const localVarPath = `/api/groups/{privateId}`
                .replace(`{${"privateId"}}`, encodeURIComponent(String(privateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetPublicGroup(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling groupsControllerGetPublicGroup.');
            }
            const localVarPath = `/api/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerJoinGroup(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling groupsControllerJoinGroup.');
            }
            const localVarPath = `/api/groups/join/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerLeaveGroup(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling groupsControllerLeaveGroup.');
            }
            const localVarPath = `/api/groups/leave/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateGroupDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerCreateGroup(body: CreateGroupDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateGroupSuccessDto> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).groupsControllerCreateGroup(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetGroups(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetGroupsSuccessDto> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).groupsControllerGetGroups(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetMembersAndPosts(groupID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetGroupMembersAndPostsDto> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).groupsControllerGetMembersAndPosts(groupID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} privateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetPrivateGroup(privateId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupDto> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).groupsControllerGetPrivateGroup(privateId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetPublicGroup(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupDto> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).groupsControllerGetPublicGroup(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerJoinGroup(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).groupsControllerJoinGroup(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerLeaveGroup(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).groupsControllerLeaveGroup(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CreateGroupDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerCreateGroup(body: CreateGroupDto, options?: any) {
            return GroupsApiFp(configuration).groupsControllerCreateGroup(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetGroups(options?: any) {
            return GroupsApiFp(configuration).groupsControllerGetGroups(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetMembersAndPosts(groupID: string, options?: any) {
            return GroupsApiFp(configuration).groupsControllerGetMembersAndPosts(groupID, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} privateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetPrivateGroup(privateId: string, options?: any) {
            return GroupsApiFp(configuration).groupsControllerGetPrivateGroup(privateId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerGetPublicGroup(id: string, options?: any) {
            return GroupsApiFp(configuration).groupsControllerGetPublicGroup(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerJoinGroup(id: string, options?: any) {
            return GroupsApiFp(configuration).groupsControllerJoinGroup(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsControllerLeaveGroup(id: string, options?: any) {
            return GroupsApiFp(configuration).groupsControllerLeaveGroup(id, options)(fetch, basePath);
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @param {CreateGroupDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerCreateGroup(body: CreateGroupDto, options?: any) {
        return GroupsApiFp(this.configuration).groupsControllerCreateGroup(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerGetGroups(options?: any) {
        return GroupsApiFp(this.configuration).groupsControllerGetGroups(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} groupID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerGetMembersAndPosts(groupID: string, options?: any) {
        return GroupsApiFp(this.configuration).groupsControllerGetMembersAndPosts(groupID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} privateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerGetPrivateGroup(privateId: string, options?: any) {
        return GroupsApiFp(this.configuration).groupsControllerGetPrivateGroup(privateId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerGetPublicGroup(id: string, options?: any) {
        return GroupsApiFp(this.configuration).groupsControllerGetPublicGroup(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerJoinGroup(id: string, options?: any) {
        return GroupsApiFp(this.configuration).groupsControllerJoinGroup(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsControllerLeaveGroup(id: string, options?: any) {
        return GroupsApiFp(this.configuration).groupsControllerLeaveGroup(id, options)(this.fetch, this.basePath);
    }

}
/**
 * MessagesApi - fetch parameter creator
 * @export
 */
export const MessagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateMessageBodyDto} body 
         * @param {string} conversationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesControllerCreateMessage(body: CreateMessageBodyDto, conversationID: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling messagesControllerCreateMessage.');
            }
            // verify required parameter 'conversationID' is not null or undefined
            if (conversationID === null || conversationID === undefined) {
                throw new RequiredError('conversationID','Required parameter conversationID was null or undefined when calling messagesControllerCreateMessage.');
            }
            const localVarPath = `/api/messages/{conversationID}`
                .replace(`{${"conversationID"}}`, encodeURIComponent(String(conversationID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateMessageBodyDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} conversationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesControllerGetMessagesInConversation(conversationID: string, options: any = {}): FetchArgs {
            // verify required parameter 'conversationID' is not null or undefined
            if (conversationID === null || conversationID === undefined) {
                throw new RequiredError('conversationID','Required parameter conversationID was null or undefined when calling messagesControllerGetMessagesInConversation.');
            }
            const localVarPath = `/api/messages/{conversationID}`
                .replace(`{${"conversationID"}}`, encodeURIComponent(String(conversationID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateMessageBodyDto} body 
         * @param {string} conversationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesControllerCreateMessage(body: CreateMessageBodyDto, conversationID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateMessageSuccessDto> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).messagesControllerCreateMessage(body, conversationID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} conversationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesControllerGetMessagesInConversation(conversationID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MessageDto>> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).messagesControllerGetMessagesInConversation(conversationID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CreateMessageBodyDto} body 
         * @param {string} conversationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesControllerCreateMessage(body: CreateMessageBodyDto, conversationID: string, options?: any) {
            return MessagesApiFp(configuration).messagesControllerCreateMessage(body, conversationID, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} conversationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messagesControllerGetMessagesInConversation(conversationID: string, options?: any) {
            return MessagesApiFp(configuration).messagesControllerGetMessagesInConversation(conversationID, options)(fetch, basePath);
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * 
     * @param {CreateMessageBodyDto} body 
     * @param {string} conversationID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesControllerCreateMessage(body: CreateMessageBodyDto, conversationID: string, options?: any) {
        return MessagesApiFp(this.configuration).messagesControllerCreateMessage(body, conversationID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} conversationID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public messagesControllerGetMessagesInConversation(conversationID: string, options?: any) {
        return MessagesApiFp(this.configuration).messagesControllerGetMessagesInConversation(conversationID, options)(this.fetch, this.basePath);
    }

}
/**
 * PostsApi - fetch parameter creator
 * @export
 */
export const PostsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePostBodyDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerCreatePost(body: CreatePostBodyDto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postsControllerCreatePost.');
            }
            const localVarPath = `/api/posts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreatePostBodyDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerDeletePostByPostID(postID: string, options: any = {}): FetchArgs {
            // verify required parameter 'postID' is not null or undefined
            if (postID === null || postID === undefined) {
                throw new RequiredError('postID','Required parameter postID was null or undefined when calling postsControllerDeletePostByPostID.');
            }
            const localVarPath = `/api/posts/{postID}`
                .replace(`{${"postID"}}`, encodeURIComponent(String(postID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerGetPostByID(postID: string, options: any = {}): FetchArgs {
            // verify required parameter 'postID' is not null or undefined
            if (postID === null || postID === undefined) {
                throw new RequiredError('postID','Required parameter postID was null or undefined when calling postsControllerGetPostByID.');
            }
            const localVarPath = `/api/posts/byID/{postID}`
                .replace(`{${"postID"}}`, encodeURIComponent(String(postID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} slug 
         * @param {boolean} getAuthor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerGetPostBySlug(slug: string, getAuthor: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'slug' is not null or undefined
            if (slug === null || slug === undefined) {
                throw new RequiredError('slug','Required parameter slug was null or undefined when calling postsControllerGetPostBySlug.');
            }
            // verify required parameter 'getAuthor' is not null or undefined
            if (getAuthor === null || getAuthor === undefined) {
                throw new RequiredError('getAuthor','Required parameter getAuthor was null or undefined when calling postsControllerGetPostBySlug.');
            }
            const localVarPath = `/api/posts/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (getAuthor !== undefined) {
                localVarQueryParameter['get-author'] = getAuthor;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerIncrementView(postID: string, options: any = {}): FetchArgs {
            // verify required parameter 'postID' is not null or undefined
            if (postID === null || postID === undefined) {
                throw new RequiredError('postID','Required parameter postID was null or undefined when calling postsControllerIncrementView.');
            }
            const localVarPath = `/api/posts/increment-view/{postID}`
                .replace(`{${"postID"}}`, encodeURIComponent(String(postID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerLikePost(postID: string, options: any = {}): FetchArgs {
            // verify required parameter 'postID' is not null or undefined
            if (postID === null || postID === undefined) {
                throw new RequiredError('postID','Required parameter postID was null or undefined when calling postsControllerLikePost.');
            }
            const localVarPath = `/api/posts/like`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            if (postID !== undefined) {
                localVarQueryParameter['postID'] = postID;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerUnlikePost(postID: string, options: any = {}): FetchArgs {
            // verify required parameter 'postID' is not null or undefined
            if (postID === null || postID === undefined) {
                throw new RequiredError('postID','Required parameter postID was null or undefined when calling postsControllerUnlikePost.');
            }
            const localVarPath = `/api/posts/unlike`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            if (postID !== undefined) {
                localVarQueryParameter['postID'] = postID;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdatePostBodyDto} body 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerUpdatePostBySlug(body: UpdatePostBodyDto, slug: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postsControllerUpdatePostBySlug.');
            }
            // verify required parameter 'slug' is not null or undefined
            if (slug === null || slug === undefined) {
                throw new RequiredError('slug','Required parameter slug was null or undefined when calling postsControllerUpdatePostBySlug.');
            }
            const localVarPath = `/api/posts/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatePostBodyDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tagID The ObjectID of the tag
         * @param {number} [requestedCount] How many posts to fetch
         * @param {number} [startIdx] What index to start at, e.g. if startIdx &#x3D; 5, then the 5 posts (0th, 1st, 2nd, 3rd, 4th) of this tag will not be fetched
         * @param {any} [excludePostIDs] An object that works like a set of Post ObjectIDs to exclude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsControllerGetPostsByTag(tagID: string, requestedCount?: number, startIdx?: number, excludePostIDs?: any, options: any = {}): FetchArgs {
            // verify required parameter 'tagID' is not null or undefined
            if (tagID === null || tagID === undefined) {
                throw new RequiredError('tagID','Required parameter tagID was null or undefined when calling tagsControllerGetPostsByTag.');
            }
            const localVarPath = `/api/tags/posts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tagID !== undefined) {
                localVarQueryParameter['tagID'] = tagID;
            }

            if (requestedCount !== undefined) {
                localVarQueryParameter['requestedCount'] = requestedCount;
            }

            if (startIdx !== undefined) {
                localVarQueryParameter['startIdx'] = startIdx;
            }

            if (excludePostIDs !== undefined) {
                localVarQueryParameter['excludePostIDs'] = excludePostIDs;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePostBodyDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerCreatePost(body: CreatePostBodyDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreatePostSuccessDto> {
            const localVarFetchArgs = PostsApiFetchParamCreator(configuration).postsControllerCreatePost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerDeletePostByPostID(postID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PostsApiFetchParamCreator(configuration).postsControllerDeletePostByPostID(postID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerGetPostByID(postID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPostDetailsSuccessDto> {
            const localVarFetchArgs = PostsApiFetchParamCreator(configuration).postsControllerGetPostByID(postID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} slug 
         * @param {boolean} getAuthor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerGetPostBySlug(slug: string, getAuthor: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPostDetailsSuccessDto> {
            const localVarFetchArgs = PostsApiFetchParamCreator(configuration).postsControllerGetPostBySlug(slug, getAuthor, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerIncrementView(postID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PostsApiFetchParamCreator(configuration).postsControllerIncrementView(postID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerLikePost(postID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PostsApiFetchParamCreator(configuration).postsControllerLikePost(postID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerUnlikePost(postID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PostsApiFetchParamCreator(configuration).postsControllerUnlikePost(postID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdatePostBodyDto} body 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerUpdatePostBySlug(body: UpdatePostBodyDto, slug: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UpdatePostSuccessDto> {
            const localVarFetchArgs = PostsApiFetchParamCreator(configuration).postsControllerUpdatePostBySlug(body, slug, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} tagID The ObjectID of the tag
         * @param {number} [requestedCount] How many posts to fetch
         * @param {number} [startIdx] What index to start at, e.g. if startIdx &#x3D; 5, then the 5 posts (0th, 1st, 2nd, 3rd, 4th) of this tag will not be fetched
         * @param {any} [excludePostIDs] An object that works like a set of Post ObjectIDs to exclude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsControllerGetPostsByTag(tagID: string, requestedCount?: number, startIdx?: number, excludePostIDs?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPostsByTagDto> {
            const localVarFetchArgs = PostsApiFetchParamCreator(configuration).tagsControllerGetPostsByTag(tagID, requestedCount, startIdx, excludePostIDs, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CreatePostBodyDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerCreatePost(body: CreatePostBodyDto, options?: any) {
            return PostsApiFp(configuration).postsControllerCreatePost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerDeletePostByPostID(postID: string, options?: any) {
            return PostsApiFp(configuration).postsControllerDeletePostByPostID(postID, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerGetPostByID(postID: string, options?: any) {
            return PostsApiFp(configuration).postsControllerGetPostByID(postID, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} slug 
         * @param {boolean} getAuthor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerGetPostBySlug(slug: string, getAuthor: boolean, options?: any) {
            return PostsApiFp(configuration).postsControllerGetPostBySlug(slug, getAuthor, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerIncrementView(postID: string, options?: any) {
            return PostsApiFp(configuration).postsControllerIncrementView(postID, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerLikePost(postID: string, options?: any) {
            return PostsApiFp(configuration).postsControllerLikePost(postID, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerUnlikePost(postID: string, options?: any) {
            return PostsApiFp(configuration).postsControllerUnlikePost(postID, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdatePostBodyDto} body 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postsControllerUpdatePostBySlug(body: UpdatePostBodyDto, slug: string, options?: any) {
            return PostsApiFp(configuration).postsControllerUpdatePostBySlug(body, slug, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} tagID The ObjectID of the tag
         * @param {number} [requestedCount] How many posts to fetch
         * @param {number} [startIdx] What index to start at, e.g. if startIdx &#x3D; 5, then the 5 posts (0th, 1st, 2nd, 3rd, 4th) of this tag will not be fetched
         * @param {any} [excludePostIDs] An object that works like a set of Post ObjectIDs to exclude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsControllerGetPostsByTag(tagID: string, requestedCount?: number, startIdx?: number, excludePostIDs?: any, options?: any) {
            return PostsApiFp(configuration).tagsControllerGetPostsByTag(tagID, requestedCount, startIdx, excludePostIDs, options)(fetch, basePath);
        },
    };
};

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
    /**
     * 
     * @param {CreatePostBodyDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsControllerCreatePost(body: CreatePostBodyDto, options?: any) {
        return PostsApiFp(this.configuration).postsControllerCreatePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} postID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsControllerDeletePostByPostID(postID: string, options?: any) {
        return PostsApiFp(this.configuration).postsControllerDeletePostByPostID(postID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} postID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsControllerGetPostByID(postID: string, options?: any) {
        return PostsApiFp(this.configuration).postsControllerGetPostByID(postID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} slug 
     * @param {boolean} getAuthor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsControllerGetPostBySlug(slug: string, getAuthor: boolean, options?: any) {
        return PostsApiFp(this.configuration).postsControllerGetPostBySlug(slug, getAuthor, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} postID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsControllerIncrementView(postID: string, options?: any) {
        return PostsApiFp(this.configuration).postsControllerIncrementView(postID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} postID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsControllerLikePost(postID: string, options?: any) {
        return PostsApiFp(this.configuration).postsControllerLikePost(postID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} postID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsControllerUnlikePost(postID: string, options?: any) {
        return PostsApiFp(this.configuration).postsControllerUnlikePost(postID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UpdatePostBodyDto} body 
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postsControllerUpdatePostBySlug(body: UpdatePostBodyDto, slug: string, options?: any) {
        return PostsApiFp(this.configuration).postsControllerUpdatePostBySlug(body, slug, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} tagID The ObjectID of the tag
     * @param {number} [requestedCount] How many posts to fetch
     * @param {number} [startIdx] What index to start at, e.g. if startIdx &#x3D; 5, then the 5 posts (0th, 1st, 2nd, 3rd, 4th) of this tag will not be fetched
     * @param {any} [excludePostIDs] An object that works like a set of Post ObjectIDs to exclude
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public tagsControllerGetPostsByTag(tagID: string, requestedCount?: number, startIdx?: number, excludePostIDs?: any, options?: any) {
        return PostsApiFp(this.configuration).tagsControllerGetPostsByTag(tagID, requestedCount, startIdx, excludePostIDs, options)(this.fetch, this.basePath);
    }

}
/**
 * SearchApi - fetch parameter creator
 * @export
 */
export const SearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Finds posts containing any of the terms in the query string
         * @param {string} q 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearch(q: string, options: any = {}): FetchArgs {
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new RequiredError('q','Required parameter q was null or undefined when calling searchControllerSearch.');
            }
            const localVarPath = `/api/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Finds posts containing any of the terms in the query string
         * @param {string} q 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearch(q: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchResultDto> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).searchControllerSearch(q, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Finds posts containing any of the terms in the query string
         * @param {string} q 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearch(q: string, options?: any) {
            return SearchApiFp(configuration).searchControllerSearch(q, options)(fetch, basePath);
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Finds posts containing any of the terms in the query string
     * @param {string} q 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerSearch(q: string, options?: any) {
        return SearchApiFp(this.configuration).searchControllerSearch(q, options)(this.fetch, this.basePath);
    }

}
/**
 * TrendingApi - fetch parameter creator
 * @export
 */
export const TrendingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} fetchCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingControllerGetTrending(fetchCount: number, options: any = {}): FetchArgs {
            // verify required parameter 'fetchCount' is not null or undefined
            if (fetchCount === null || fetchCount === undefined) {
                throw new RequiredError('fetchCount','Required parameter fetchCount was null or undefined when calling trendingControllerGetTrending.');
            }
            const localVarPath = `/api/trending/fetchCount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fetchCount !== undefined) {
                localVarQueryParameter['fetchCount'] = fetchCount;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} fetchCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingControllerGetTrendingLoggedIn(fetchCount: number, options: any = {}): FetchArgs {
            // verify required parameter 'fetchCount' is not null or undefined
            if (fetchCount === null || fetchCount === undefined) {
                throw new RequiredError('fetchCount','Required parameter fetchCount was null or undefined when calling trendingControllerGetTrendingLoggedIn.');
            }
            const localVarPath = `/api/trending/loggedIn`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fetchCount !== undefined) {
                localVarQueryParameter['fetchCount'] = fetchCount;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrendingApi - functional programming interface
 * @export
 */
export const TrendingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} fetchCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingControllerGetTrending(fetchCount: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInitialDataDto> {
            const localVarFetchArgs = TrendingApiFetchParamCreator(configuration).trendingControllerGetTrending(fetchCount, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} fetchCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingControllerGetTrendingLoggedIn(fetchCount: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetInitialDataLoggedInDto> {
            const localVarFetchArgs = TrendingApiFetchParamCreator(configuration).trendingControllerGetTrendingLoggedIn(fetchCount, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TrendingApi - factory interface
 * @export
 */
export const TrendingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} fetchCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingControllerGetTrending(fetchCount: number, options?: any) {
            return TrendingApiFp(configuration).trendingControllerGetTrending(fetchCount, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} fetchCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingControllerGetTrendingLoggedIn(fetchCount: number, options?: any) {
            return TrendingApiFp(configuration).trendingControllerGetTrendingLoggedIn(fetchCount, options)(fetch, basePath);
        },
    };
};

/**
 * TrendingApi - object-oriented interface
 * @export
 * @class TrendingApi
 * @extends {BaseAPI}
 */
export class TrendingApi extends BaseAPI {
    /**
     * 
     * @param {number} fetchCount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendingApi
     */
    public trendingControllerGetTrending(fetchCount: number, options?: any) {
        return TrendingApiFp(this.configuration).trendingControllerGetTrending(fetchCount, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} fetchCount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrendingApi
     */
    public trendingControllerGetTrendingLoggedIn(fetchCount: number, options?: any) {
        return TrendingApiFp(this.configuration).trendingControllerGetTrendingLoggedIn(fetchCount, options)(this.fetch, this.basePath);
    }

}
/**
 * UploadApi - fetch parameter creator
 * @export
 */
export const UploadApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Not implemented. Once implemented, use helper function in 'frontend/src/api-upload'. (Don't use 'new UploadApi().uploadController ...' from 'frontend/src/api' as it does not work.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadPrivateFile(options: any = {}): FetchArgs {
            const localVarPath = `/api/upload/private/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: use helper function in 'frontend/src/api-upload'. (Don't use 'new UploadApi().uploadController ...' from 'frontend/src/api' as it does not work. )
         * @param {FileUploadDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadProfileBannerPic(body: FileUploadDto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadControllerUploadProfileBannerPic.');
            }
            const localVarPath = `/api/upload/profile-banner-pic`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FileUploadDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: use helper function in 'frontend/src/api-upload'. The generated version for this front end API helpers (frontend/src/api) doesn't work.
         * @param {FileUploadDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadProfilePic(body: FileUploadDto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadControllerUploadProfilePic.');
            }
            const localVarPath = `/api/upload/profile-pic`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FileUploadDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: use helper function in 'frontend/src/api-upload'. (Don't use 'new UploadApi().uploadController ...' from 'frontend/src/api' as it does not work.)
         * @param {FileUploadDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadPublicAsset(body: FileUploadDto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadControllerUploadPublicAsset.');
            }
            const localVarPath = `/api/upload/public/asset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FileUploadDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadApi - functional programming interface
 * @export
 */
export const UploadApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Not implemented. Once implemented, use helper function in 'frontend/src/api-upload'. (Don't use 'new UploadApi().uploadController ...' from 'frontend/src/api' as it does not work.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadPrivateFile(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UploadSuccess> {
            const localVarFetchArgs = UploadApiFetchParamCreator(configuration).uploadControllerUploadPrivateFile(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Note: use helper function in 'frontend/src/api-upload'. (Don't use 'new UploadApi().uploadController ...' from 'frontend/src/api' as it does not work. )
         * @param {FileUploadDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadProfileBannerPic(body: FileUploadDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UploadSuccess> {
            const localVarFetchArgs = UploadApiFetchParamCreator(configuration).uploadControllerUploadProfileBannerPic(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Note: use helper function in 'frontend/src/api-upload'. The generated version for this front end API helpers (frontend/src/api) doesn't work.
         * @param {FileUploadDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadProfilePic(body: FileUploadDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UploadSuccess> {
            const localVarFetchArgs = UploadApiFetchParamCreator(configuration).uploadControllerUploadProfilePic(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Note: use helper function in 'frontend/src/api-upload'. (Don't use 'new UploadApi().uploadController ...' from 'frontend/src/api' as it does not work.)
         * @param {FileUploadDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadPublicAsset(body: FileUploadDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UploadSuccess> {
            const localVarFetchArgs = UploadApiFetchParamCreator(configuration).uploadControllerUploadPublicAsset(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UploadApi - factory interface
 * @export
 */
export const UploadApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Not implemented. Once implemented, use helper function in 'frontend/src/api-upload'. (Don't use 'new UploadApi().uploadController ...' from 'frontend/src/api' as it does not work.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadPrivateFile(options?: any) {
            return UploadApiFp(configuration).uploadControllerUploadPrivateFile(options)(fetch, basePath);
        },
        /**
         * Note: use helper function in 'frontend/src/api-upload'. (Don't use 'new UploadApi().uploadController ...' from 'frontend/src/api' as it does not work. )
         * @param {FileUploadDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadProfileBannerPic(body: FileUploadDto, options?: any) {
            return UploadApiFp(configuration).uploadControllerUploadProfileBannerPic(body, options)(fetch, basePath);
        },
        /**
         * Note: use helper function in 'frontend/src/api-upload'. The generated version for this front end API helpers (frontend/src/api) doesn't work.
         * @param {FileUploadDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadProfilePic(body: FileUploadDto, options?: any) {
            return UploadApiFp(configuration).uploadControllerUploadProfilePic(body, options)(fetch, basePath);
        },
        /**
         * Note: use helper function in 'frontend/src/api-upload'. (Don't use 'new UploadApi().uploadController ...' from 'frontend/src/api' as it does not work.)
         * @param {FileUploadDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadControllerUploadPublicAsset(body: FileUploadDto, options?: any) {
            return UploadApiFp(configuration).uploadControllerUploadPublicAsset(body, options)(fetch, basePath);
        },
    };
};

/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
export class UploadApi extends BaseAPI {
    /**
     * Not implemented. Once implemented, use helper function in 'frontend/src/api-upload'. (Don't use 'new UploadApi().uploadController ...' from 'frontend/src/api' as it does not work.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public uploadControllerUploadPrivateFile(options?: any) {
        return UploadApiFp(this.configuration).uploadControllerUploadPrivateFile(options)(this.fetch, this.basePath);
    }

    /**
     * Note: use helper function in 'frontend/src/api-upload'. (Don't use 'new UploadApi().uploadController ...' from 'frontend/src/api' as it does not work. )
     * @param {FileUploadDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public uploadControllerUploadProfileBannerPic(body: FileUploadDto, options?: any) {
        return UploadApiFp(this.configuration).uploadControllerUploadProfileBannerPic(body, options)(this.fetch, this.basePath);
    }

    /**
     * Note: use helper function in 'frontend/src/api-upload'. The generated version for this front end API helpers (frontend/src/api) doesn't work.
     * @param {FileUploadDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public uploadControllerUploadProfilePic(body: FileUploadDto, options?: any) {
        return UploadApiFp(this.configuration).uploadControllerUploadProfilePic(body, options)(this.fetch, this.basePath);
    }

    /**
     * Note: use helper function in 'frontend/src/api-upload'. (Don't use 'new UploadApi().uploadController ...' from 'frontend/src/api' as it does not work.)
     * @param {FileUploadDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public uploadControllerUploadPublicAsset(body: FileUploadDto, options?: any) {
        return UploadApiFp(this.configuration).uploadControllerUploadPublicAsset(body, options)(this.fetch, this.basePath);
    }

}
/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerAddFollowing(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userControllerAddFollowing.');
            }
            const localVarPath = `/api/user/addFollowing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For updating user's name, status and tags. To update profile image or banner image, use their upload endpoints instead.
         * @param {UpdateProfileReqDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerEditProfile(body: UpdateProfileReqDto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling userControllerEditProfile.');
            }
            const localVarPath = `/api/user/edit-profile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateProfileReqDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUserByUsername(username: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling userControllerGetUserByUsername.');
            }
            const localVarPath = `/api/user/byUsername/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUsersByIDs(ids: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids','Required parameter ids was null or undefined when calling userControllerGetUsersByIDs.');
            }
            const localVarPath = `/api/user/byIds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemoveFollowing(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userControllerRemoveFollowing.');
            }
            const localVarPath = `/api/user/removeFollowing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerSavePost(postID: string, options: any = {}): FetchArgs {
            // verify required parameter 'postID' is not null or undefined
            if (postID === null || postID === undefined) {
                throw new RequiredError('postID','Required parameter postID was null or undefined when calling userControllerSavePost.');
            }
            const localVarPath = `/api/user/save-post/{postID}`
                .replace(`{${"postID"}}`, encodeURIComponent(String(postID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerAddFollowing(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userControllerAddFollowing(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * For updating user's name, status and tags. To update profile image or banner image, use their upload endpoints instead.
         * @param {UpdateProfileReqDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerEditProfile(body: UpdateProfileReqDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userControllerEditProfile(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the current logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDto> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userControllerGetUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUserByUsername(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDto> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userControllerGetUserByUsername(username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUsersByIDs(ids: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetUsersSuccessDto> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userControllerGetUsersByIDs(ids, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemoveFollowing(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userControllerRemoveFollowing(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerSavePost(postID: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).userControllerSavePost(postID, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerAddFollowing(id: string, options?: any) {
            return UserApiFp(configuration).userControllerAddFollowing(id, options)(fetch, basePath);
        },
        /**
         * For updating user's name, status and tags. To update profile image or banner image, use their upload endpoints instead.
         * @param {UpdateProfileReqDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerEditProfile(body: UpdateProfileReqDto, options?: any) {
            return UserApiFp(configuration).userControllerEditProfile(body, options)(fetch, basePath);
        },
        /**
         * Retrieve the current logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUser(options?: any) {
            return UserApiFp(configuration).userControllerGetUser(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUserByUsername(username: string, options?: any) {
            return UserApiFp(configuration).userControllerGetUserByUsername(username, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUsersByIDs(ids: string, options?: any) {
            return UserApiFp(configuration).userControllerGetUsersByIDs(ids, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemoveFollowing(id: string, options?: any) {
            return UserApiFp(configuration).userControllerRemoveFollowing(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} postID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerSavePost(postID: string, options?: any) {
            return UserApiFp(configuration).userControllerSavePost(postID, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerAddFollowing(id: string, options?: any) {
        return UserApiFp(this.configuration).userControllerAddFollowing(id, options)(this.fetch, this.basePath);
    }

    /**
     * For updating user's name, status and tags. To update profile image or banner image, use their upload endpoints instead.
     * @param {UpdateProfileReqDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerEditProfile(body: UpdateProfileReqDto, options?: any) {
        return UserApiFp(this.configuration).userControllerEditProfile(body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve the current logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerGetUser(options?: any) {
        return UserApiFp(this.configuration).userControllerGetUser(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerGetUserByUsername(username: string, options?: any) {
        return UserApiFp(this.configuration).userControllerGetUserByUsername(username, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerGetUsersByIDs(ids: string, options?: any) {
        return UserApiFp(this.configuration).userControllerGetUsersByIDs(ids, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerRemoveFollowing(id: string, options?: any) {
        return UserApiFp(this.configuration).userControllerRemoveFollowing(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} postID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerSavePost(postID: string, options?: any) {
        return UserApiFp(this.configuration).userControllerSavePost(postID, options)(this.fetch, this.basePath);
    }

}
/**
 * VideoApi - fetch parameter creator
 * @export
 */
export const VideoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateVideoDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoControllerCreateVideo(body: CreateVideoDto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling videoControllerCreateVideo.');
            }
            const localVarPath = `/api/video`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateVideoDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoControllerGetAllVideos(options: any = {}): FetchArgs {
            const localVarPath = `/api/video`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoApi - functional programming interface
 * @export
 */
export const VideoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateVideoDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoControllerCreateVideo(body: CreateVideoDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VideoDto> {
            const localVarFetchArgs = VideoApiFetchParamCreator(configuration).videoControllerCreateVideo(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoControllerGetAllVideos(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAllVideosDto> {
            const localVarFetchArgs = VideoApiFetchParamCreator(configuration).videoControllerGetAllVideos(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VideoApi - factory interface
 * @export
 */
export const VideoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CreateVideoDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoControllerCreateVideo(body: CreateVideoDto, options?: any) {
            return VideoApiFp(configuration).videoControllerCreateVideo(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoControllerGetAllVideos(options?: any) {
            return VideoApiFp(configuration).videoControllerGetAllVideos(options)(fetch, basePath);
        },
    };
};

/**
 * VideoApi - object-oriented interface
 * @export
 * @class VideoApi
 * @extends {BaseAPI}
 */
export class VideoApi extends BaseAPI {
    /**
     * 
     * @param {CreateVideoDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public videoControllerCreateVideo(body: CreateVideoDto, options?: any) {
        return VideoApiFp(this.configuration).videoControllerCreateVideo(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoApi
     */
    public videoControllerGetAllVideos(options?: any) {
        return VideoApiFp(this.configuration).videoControllerGetAllVideos(options)(this.fetch, this.basePath);
    }

}
